# 二进制和EVM上的类型
Solidity有许多有用的类型：uint256、bool、string、struct、mapping、arrays等等。

然而，EVM本身并不知道这些类型。没有任何与大多数Solidity类型相关或知晓的操作码。相反，它们处理更低级别的类型，如下所示。

## 二进制的回顾
如果您已经熟悉二进制和字节，可以跳过本节。

对于那些需要复习的人，这里是一个快速回顾：
- 二进制是由0和1组成的字符串（0和1）
- 每个0或1称为一个bit。
- 8个bit=1个字节——例如，0101 1000是一个字节（中间的空格只是为了更易读）。
- 二进制是原始数据。它没有类型。
- 然而，我们可以将二进制值解释为一种类型。
    - 通过“我们”，我指的是我们作为人类，或者我们编写的程序。
    - 例如，我们可以将0101 1000解释为无符号整数，将每个比特转换为其相应的2的幂次：
      - `0+64+0+16+8+0+0+0=88`
    - 另一方面，我们可以将相同的值解释为ASCII，即字母x。
- 1个字节有256个可能的值。
    - 0000 0000、0000 0001、0000 0010、0000 0011、0000 0100等等。
    - 作为无符号整数，1个字节的最小值为0，最大值为255。

## EVM的本机类型
EVM理解的“类型”包括：
- 无符号数（uint256），由ADD、SUB、LT、GT、GAS、CALLVALUE、TIMESTAMP等支持。
- 有符号数（int256），由SIGNEXTEND、SDIV、SLT、SGT等支持。
- 二进制，由AND、OR、XOR、BYTE、SHL、SHR、SHA3、BLOCKHASH等支持。
- 地址，由ADDRESS、SENDER、CALL等支持。
- 合约字节码，由CREATE、CODECOPY、EXTCODECOPY等支持。

您在Solidity中看到的所有其他类型都是在上述类型的基础上构建的。

请注意，EVM中的任何值——无论是在堆栈、内存还是存储中-都只是二进制，并且只有在操作码对该数据进行操作时才解释为一种类型。

## 256位字长
字长是所有机器都具有的东西-它是它们操作的数据的“自然块大小”。

但是这是什么意思呢？

从根本上说，您的计算机有限制。它有有限的内存量，有限的磁盘空间等等。

在二进制的最低级别存在着相同类型的限制。对于一台机器来说，堆栈项必须具有某种长度限制。

**EVM的堆栈项大小是其字长：256位（32字节）。**

这意味着每个堆栈项都恰好是256位。多一点也不行，少一点也不行。例如，一个布尔值将在堆栈上占用整个256位，即使布尔值只需要一位来完全表示。这可能是很多未使用空间。

> 再次强调：EVM没有内置的布尔概念。

EVM的大字长对您如何与系统交互有许多影响。让我们逐个探讨每个影响。

## 堆栈项的数据大小
如上所示，堆栈上的每个项都是完整的32字节。任何一个操作码放在堆栈上的项都将是这个大小；没有其他指定的方式。

## 委托给内存
尽管32字节很大，但并不是所有的东西都能适应一个字长。复杂的数据结构，如数组和字符串，至少需要两个完整字长-一个用于长度，另一个或更多用于数据。

因此，通常情况下，您将不得不将数据移到内存中，而不是堆栈中。其中一个最常见的例子是RETURN操作码；为了从函数调用中返回数据，您必须首先将数据放入内存中，然后使用数据在内存中的位置执行RETURN操作码。


## 关键空间
在使用内存时，您指定一个内存偏移量-一个32字节的偏移量，从零开始，表示您的数据在内存中的位置。

在使用存储时，您指定一个存储键-一个32字节的键，可以是任何值，表示您要读取或写入32字节值的数据的位置。

考虑一下32字节键有2^256个可能的值。这是一个非常大的数字：

    2^256 = 115,792,089,237,316,195,423,570,985,008,687,907,853,269,984,665,640,564,039,457,584,007,913,129,639,936

这对于存储来说非常适用，因为EVM存储类似于键值数据库；任何32字节的键都可以分配任何32字节的值。拥有如此大的键空间是一个好处，因为它有助于避免冲突。

但对于内存而言，您永远不会接近最大范围。从零开始，您使用的任何内存都需要额外的gas进行分配。例如，使用偏移量0xff是可以的；但是使用偏移量0xff000000000000000000就不行了，因为EVM将尝试从零开始分配内存直到该偏移量。

> 更具体地说，使用内存偏移量将导致EVM分配任何未使用的内存空间直到该偏移量。有关更多信息，请参阅🧱与内存一起使用。

## 存储值
合约存储值也受限于256位。这是拥有如此大的字长的一个好处；您可以更轻松地存储和检索大型值，例如keccak哈希。

例如，如果EVM是64位的，您将不得不将地址分成三个64位存储槽，从而使读写变得复杂。

## ABI编码
当您发送消息调用函数时，您会随之发送函数参数。这些参数使用ABI编码进行编码，通常使用EVM的字长来编码数据。

这意味着，就像堆栈示例一样，将bool类型编码为函数调用将在ABI编码的消息中占用整整32字节。这可能是很多未使用的空间。

## Keccak哈希
256位字长的另一个好处是方便处理占用整整32字节的keccak哈希。这些哈希可以直接在堆栈上操作。