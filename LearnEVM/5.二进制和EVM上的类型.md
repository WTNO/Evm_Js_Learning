# 二进制和EVM上的类型
Solidity有许多有用的类型：uint256、bool、string、struct、mapping、arrays等等。

然而，EVM本身并不知道这些类型。没有任何与大多数Solidity类型相关或知晓的操作码。相反，它们处理更低级别的类型，如下所示。

## 二进制的回顾
如果您已经熟悉二进制和字节，可以跳过本节。

对于那些需要复习的人，这里是一个快速回顾：
- 二进制是由0和1组成的字符串（0和1）
- 每个0或1称为一个bit。
- 8个bit=1个字节——例如，0101 1000是一个字节（中间的空格只是为了更易读）。
- 二进制是原始数据。它没有类型。
- 然而，我们可以将二进制值解释为一种类型。
    - 通过“我们”，我指的是我们作为人类，或者我们编写的程序。
    - 例如，我们可以将0101 1000解释为无符号整数，将每个比特转换为其相应的2的幂次：
      - `0+64+0+16+8+0+0+0=88`
    - 另一方面，我们可以将相同的值解释为ASCII，即字母x。
- 1个字节有256个可能的值。
    - 0000 0000、0000 0001、0000 0010、0000 0011、0000 0100等等。
    - 作为无符号整数，1个字节的最小值为0，最大值为255。

## EVM的本机类型
EVM理解的“类型”包括：
- 无符号数（uint256），由ADD、SUB、LT、GT、GAS、CALLVALUE、TIMESTAMP等支持。
- 有符号数（int256），由SIGNEXTEND、SDIV、SLT、SGT等支持。
- 二进制，由AND、OR、XOR、BYTE、SHL、SHR、SHA3、BLOCKHASH等支持。
- 地址，由ADDRESS、SENDER、CALL等支持。
- 合约字节码，由CREATE、CODECOPY、EXTCODECOPY等支持。

您在Solidity中看到的所有其他类型都是在上述类型的基础上构建的。

请注意，EVM中的任何值——无论是在堆栈、内存还是存储中-都只是二进制，并且只有在操作码对该数据进行操作时才解释为一种类型。

## 256位字长
字长是所有机器都具有的东西-它是它们操作的数据的“自然块大小”。

但是这是什么意思呢？

从根本上说，您的计算机有限制。它有有限的内存量，有限的磁盘空间等等。

在二进制的最低级别存在着相同类型的限制。对于一台机器来说，堆栈项必须具有某种长度限制。

**EVM的堆栈项大小是其字长：256位（32字节）。**

这意味着每个堆栈项都恰好是256位。多一点也不行，少一点也不行。例如，一个布尔值将在堆栈上占用整个256位，即使布尔值只需要一位来完全表示。这可能是很多未使用空间。

> 再次强调：EVM没有内置的布尔概念。

EVM的大字长对您如何与系统交互有许多影响。让我们逐个探讨每个影响。

## 堆栈项的数据大小
如上所示，堆栈上的每个项都是完整的32字节。任何一个操作码放在堆栈上的项都将是这个大小；没有其他指定的方式。

## 委托给内存
尽管32字节很大，但并不是所有的东西都能适应一个字长。复杂的数据结构，如数组和字符串，至少需要两个完整字长-一个用于长度，另一个或更多用于数据。

因此，通常情况下，您将不得不将数据移到内存中，而不是堆栈中。其中一个最常见的例子是RETURN操作码；为了从函数调用中返回数据，您必须首先将数据放入内存中，然后使用数据在内存中的位置执行RETURN操作码。


## 关键空间
在使用内存时，您指定一个内存偏移量-一个32字节的偏移量，从零开始，表示您的数据在内存中的位置。

在使用存储时，您指定一个存储键-一个32字节的键，可以是任何值，表示您要读取或写入32字节值的数据的位置。

考虑一下32字节键有2^256个可能的值。这是一个非常大的数字：