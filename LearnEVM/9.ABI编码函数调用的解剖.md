# ABI编码函数调用的解剖
正如我们在 [🔩为什么要学习ABI编码？]() 中所学到的，ABI编码在智能合约的交互和开发中被广泛使用。其主要用途是对要发送给智能合约的函数调用进行编码，期望智能合约能够解释该消息并运行您想要的代码。

在本课程中，我们将学习一个这样的函数调用消息可能是什么样子。其中涉及二进制，但是当分解开来时，它相对简单。

## 介绍
下面是一个完整的ABI编码函数调用的示例：

    0x71a6155e00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000036162630000000000000000000000000000000000000000000000000000000000

在EVM函数调用中，这些数据成为合约的calldata，合约将根据需要对其进行解码和解释。

让我们学习如何分解它。

首先，上面编码的消息意图调用这个[silly, rudimentary] 函数：

    interface Example {
        function setGreeting(bool exclaim, string greeting, uint x) external;
    }

（这只是为了方便起见编写的Solidity接口；ABI编码不是Solidity独有的，虽然Solidity确实使用它来处理函数调用）。

合约（或任何其他使用ABI的代码）必须知道setGreeting()的接口，才能为其编码和/或解码ABI消息。换句话说，您不能从消息本身推导出任何类型；您必须事先知道类型。在整个课程中请记住这一点。

现在让我们深入一点。ABI编码的函数调用有两个主要部分：
1. 函数选择器
2. 函数参数

## 函数选择器
函数选择器是一个4字节的“标识符”，用于指定要调用的函数。我们在引号中写“标识符”，因为它不是唯一的标识符；两个函数有相同的函数选择器的可能性是存在的，而且这种可能性足以成为安全问题，特别是在使用高级智能合约模式（例如可升级性）时（稍后会详细讨论）。

下面是函数选择器生成的简要描述：
1. 将函数名称和所有参数类型（不包括名称）按特定格式放入字符串中。
2. 对该字符串进行keccak256哈希。
3. 取该哈希的前4个字节。

在JavaScript中：

    let ethers = require('ethers');
    let bytestring = ethers.utils.toUtf8Bytes('setGreeting(bool,string,uint256) ');
    let hash = ethers.utils.keccak256(bytestring);

    // 0x前缀2个字符；4字节8个字符。
    let selector = hash.substring(0, 2 + 8);

    selector //=> "0x71a6155e"

仔细看一下代码示例中使用的字符串。注意：
- 省略了参数名称
- 类型都是显式的（例如uint256而不是uint）
- 省略了Solidity特定的概念（例如字符串参数的内存）
- 名称和参数必须以这种确切的格式 - 括号，逗号和没有空格。

由于我们只取哈希的前四个字节，很容易想象到许多其他哈希具有相同的前四个字节，因此可能存在冲突的可能性。

另一方面，函数选择器始终是四个字节。这是有益的，因为它们非常常见；每当您想要在字节码中定义函数或调用函数时，您将使用函数选择器。只需要4个字节而不是完整的32个字节可以节省大量字节码大小。

## 函数参数
现在是时候深入探讨ABI编码函数调用参数的算法了。关于这个算法需要注意的关键点如下：

- 类型必须事先知道。换句话说，类型本身并不具备自描述能力。例如，如果你收到值0x01，仅凭该值本身，你无法确定它是一个数字、布尔值、地址等。这就是为什么你必须了解函数的接口，才能知道你正在处理的类型。
- 不属于EVM的一部分。ABI编码是一种约定。从技术上讲，EVM并不“知道”什么是字符串或布尔值（参见🧱 二进制和类型）。ABI编码是一个标准，几乎每个人都实现了它，这使得智能合约生态系统之间具有高度的互操作性。
- 在其他地方也有使用。函数调用的返回值和事件数据都使用相同的算法来编码和解码它们的值。

## 数据类型分解
回想一下，我们正在处理这个ABI编码的函数调用（上面的例子）：

    0x71a6155e00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000036162630000000000000000000000000000000000000000000000000000000000

发送到一个声称具有以下接口的合约：

    interface Example {
        function setGreeting(bool exclaim, string greeting, uint x) external;
    }

为了解析这个ABI编码的消息，首先我们要做的是将其分成三个部分：
1. 函数选择器：前面解释过的4个字节的选择器。
2. 参数：函数所需的每个参数的一个字（32个字节）。
3. 复杂数据（如果有）：不适合单个字的复杂类型的数据（字符串、数组等）。

将我们的例子分成这些部分，我们得到：

    0x // 被丢弃；不是发送的数据的一部分，只是人眼可见的前缀。

    // 1. 函数选择器
    71a6155e

    // 2. 参数
    0000000000000000000000000000000000000000000000000000000000000001 - 布尔值
    0000000000000000000000000000000000000000000000000000000000000060 - 字符串偏移量
    0000000000000000000000000000000000000000000000000000000000000001 - uint256

    // 3. 复杂数据
    0000000000000000000000000000000000000000000000000000000000000003 - 字符串长度
    6162630000000000000000000000000000000000000000000000000000000000 - 字符串数据

需要注意的几点：
- 在参数部分，每个参数都有一个字（32个字节）。
- 对于简单数据类型（布尔值和uint256），数据直接存储在该字中（分别为true和1，都以二进制值0x1表示）。
- 对于复杂数据类型（字符串），数据不直接存储在该字中。相反，该字是指向实际数据的字节偏移量。
    - 在本例中，0x60是字符串数据开始的字节偏移量。
    - 0x60在十进制中是96。因此，字符串数据从参数部分的开头开始的96个字节处开始。
    - 96个字节等于3个字（32个字节 * 3）。因此，这实际上是跳过了整个参数部分，并指向复杂数据部分的开头。

对于字符串数据具体而言：
- 字符串数据的第一个字是字符串的长度。在这种情况下，为0x3。
- 接下来的floor(L / 32) + 1个字是UTF-8编码的字符串数据本身。在这种情况下，为0x616263，即UTF-8编码的字符串"abc"。

根据这个分析，再结合Example/setGreeting接口的知识，我们可以推断出这个ABI编码的函数调用等效于以下在Solidity中编写的函数调用：

    Example(someAddress).setGreeting(true, "abc", 1);

## 结论
ABI编码的函数调用是函数选择器加上其参数。
简单参数（如整数和布尔值）直接进行编码。
复杂参数（如字符串）使用一个偏移量加上任意长度的数据进行编码。
在EVM函数调用期间，所有这些数据都成为了calldata。