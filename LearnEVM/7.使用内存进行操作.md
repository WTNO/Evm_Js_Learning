# Working with Memory
在与EVM一起工作时，您的字节码可以读写一个新的、隔离的和任意的内存字符串。

在本章中我们将涵盖：
- 内存的工作原理
- 内存的使用场景
- 内存扩展
- 使用内存的操作码

## 内存的工作原理
在使用汇编级别的代码时，在大多数机器环境中，您需要在使用之前分配内存。换句话说，您需要向环境请求更多内存的权限。如果被授予，程序继续执行。否则，会出现错误。

然而，EVM不同的是，您不需要手动分配内存。您只需直接使用所需的内存位置，而无需向环境请求更多内存。

随着使用更多的内存，您将自动支付额外的内存分配费用。请继续阅读以获取更多详细信息。

### 基本操作码
与内存交互的基本操作码包括：
- `MSTORE` - 将32个字节写入到指定的内存位置。
- `MSTORE8` - 将数据的1个字节（栈顶项的最右边的8个位）写入到指定的内存位置。
- `MLOAD` - 将32个字节从指定的内存位置复制到栈上。

这些操作码每个都有两个参数：
1. 内存位置 - 写入的位置的32字节索引
2. 数据本身 - 要写入的32字节（或MSTORE8的情况下为1字节）。

尽管要写入的数据只是您放在栈上的数据，但是内存位置在概念和燃气成本上更复杂，我们将在接下来的几个部分中看到。

### 内存布局
EVM上的内存实际上是一个 $2^{256}$ 长度的字符串：
- 内存位置的行为类似于字符串索引。
- 每个索引保存一个字节的数据，初始化为0x00。
- 您可以读取或写入任何索引！至少在理论上是这样的🙂（请参见下一节“访问内存”）。

每个EVM函数调用都会获得一个全新的、隔离的内存字符串：
- 全新的意思是，内存中的每个索引都被设置为零。
- 隔离的意思是，每个函数调用都有自己的内存；它无法访问其他函数调用的内存。

### 访问内存
内存可以通过32字节的索引进行访问。这是一个巨大的键空间！

但是您无法访问整个空间。理论上是可以的，但实际上不行。

原因是内存扩展的燃气成本。从零开始，每次访问以前未访问过的内存（在同一函数调用内），您都需要为该新访问的内存支付费用。

另一方面，如果您访问的是同一函数调用内已经访问过的内存，那么您不需要支付任何额外的燃气费用，因为在这种情况下没有内存扩展。

换句话说，重用内存可以节省燃气。

在`内存扩展章节`中查看燃气成本的详细信息。

### 内存使用案例
您的EVM程序需要使用内存的主要原因有三个：
- 返回数据。您的代码要返回的任何数据都需要先存储在内存中，以便RETURN操作码可以访问它。
- 数据寿命更长。如果您在多个操作码或⚙️内部函数调用（即将推出）中操作某个数据，拥有内存中的稳定位置可以使您的操作码逻辑更简单，特别是考虑到16次swap/dup的限制。
- 更大的数据。尽管EVM的字大小很大，但并不是所有的工作值都可以放入32字节中。您将需要将内存用作更大数据量的工作空间。