# Working with Memory
在与EVM一起工作时，您的字节码可以读写一个新的、隔离的和任意的内存字符串。

在本章中我们将涵盖：
- 内存的工作原理
- 内存的使用场景
- 内存扩展
- 使用内存的操作码

## 内存的工作原理
在使用汇编级别的代码时，在大多数机器环境中，您需要在使用之前分配内存。换句话说，您需要向环境请求更多内存的权限。如果被授予，程序继续执行。否则，会出现错误。

然而，EVM不同的是，您不需要手动分配内存。您只需直接使用所需的内存位置，而无需向环境请求更多内存。

随着使用更多的内存，您将自动支付额外的内存分配费用。请继续阅读以获取更多详细信息。

### 基本操作码
与内存交互的基本操作码包括：
- `MSTORE` - 将32个字节写入到指定的内存位置。
- `MSTORE8` - 将数据的1个字节（栈顶项的最右边的8个位）写入到指定的内存位置。
- `MLOAD` - 将32个字节从指定的内存位置复制到栈上。

这些操作码每个都有两个参数：
1. 内存位置 - 写入的位置的32字节索引
2. 数据本身 - 要写入的32字节（或MSTORE8的情况下为1字节）。

尽管要写入的数据只是您放在栈上的数据，但是内存位置在概念和燃气成本上更复杂，我们将在接下来的几个部分中看到。

### 内存布局
EVM上的内存实际上是一个 $2^{256}$ 长度的字符串：
- 内存位置的行为类似于字符串索引。
- 每个索引保存一个字节的数据，初始化为0x00。
- 您可以读取或写入任何索引！至少在理论上是这样的🙂（请参见下一节“访问内存”）。

每个EVM函数调用都会获得一个全新的、隔离的内存字符串：
- 全新的意思是，内存中的每个索引都被设置为零。
- 隔离的意思是，每个函数调用都有自己的内存；它无法访问其他函数调用的内存。

### 访问内存
内存可以通过32字节的索引进行访问。这是一个巨大的键空间！

但是您无法访问整个空间。理论上是可以的，但实际上不行。

原因是内存扩展的燃气成本。从零开始，每次访问以前未访问过的内存（在同一函数调用内），您都需要为该新访问的内存支付费用。

另一方面，如果您访问的是同一函数调用内已经访问过的内存，那么您不需要支付任何额外的燃气费用，因为在这种情况下没有内存扩展。

换句话说，重用内存可以节省燃气。

在`内存扩展章节`中查看燃气成本的详细信息。

## 内存使用案例
您的EVM程序需要使用内存的主要原因有三个：
- 返回数据。您的代码要返回的任何数据都需要先存储在内存中，以便RETURN操作码可以访问它。
- 数据寿命更长。如果您在多个操作码或⚙️内部函数调用（即将推出）中操作某个数据，拥有内存中的稳定位置可以使您的操作码逻辑更简单，特别是考虑到16次swap/dup的限制。
- 更大的数据。尽管EVM的字大小很大，但并不是所有的工作值都可以放入32字节中。您将需要将内存用作更大数据量的工作空间。

### 1. 返回数据
RETURN 操作码不能直接从堆栈中返回数据。相反，您需要将数据存储到内存中，然后返回它。

以下是返回值为7的示例：

    PUSH1 0x07
    PUSH1 0x50
    MSTORE

    PUSH1 0x20
    PUSH1 0x50
    RETURN

在上述示例中：
- MSTORE 操作码有两个参数：内存位置和要存储的值。
  - 我们使用的内存位置是0x50。在实际应用中，我们希望选择一个与内存中的其他数据不冲突的位置（请注意，在这个简单的示例中，我们选择了一个唯一的值，以便代码更易于阅读）。
  - 我们要存储的值是0x07。请注意，MSTORE 总是写入32字节的数据。
- RETURN 操作码有两个参数：要返回的数据所在的内存位置，以及该数据的字节长度。
  - 我们使用的内存位置（0x50）与我们使用 MSTORE 写入的位置相同。
  - 长度为32字节（0x20），以返回我们使用 MSTORE 写入的完整数据。

一旦 RETURN 操作码执行完毕，EVM 就停止执行函数调用，并将返回数据传递给父上下文。这个父上下文可能是交易的结束，或者是另一个使用了 CALL 操作码的函数调用。

有关返回数据的更多信息，请参阅 ☎️ EVM 函数调用的工作原理（即将推出）。

### 2. 更长的数据生命周期
有时候，您需要跟踪并在函数调用的整个生命周期中不断更新的数据，但这些数据不需要在函数调用之间保持。内存是处理这种情况的理想选择。

可以说，最常见的例子是 Solidity 的 `free memory pointer`。这个值存在于内存位置 0x40。从语义上讲，它表示 "尚未使用的下一个内存位置"（请阅读更多内容，请参见 💠 Solidity 如何管理内存（即将推出））。

这不仅对 Solidity 有用，对于任何基于字节码的架构，只要在动态基础上分配内存，都可以使用它。它允许您始终掌握新数据的存放位置，而不会与现有数据冲突或覆盖。

### 3. 更大的数据
Stack items始终为32字节。而内存在这方面没有限制。

一个常见的例子是合约部署。在合约部署过程中，您的字节码需要返回新合约字节码的最终状态。

这意味着您的部署字节码将作为一个在内存中的值返回运行时字节码。这个运行时字节码肯定会比32字节大 - 在第一层上高达24千字节。这比堆栈可以容纳的要大得多。

有关此主题的更多信息，请参阅 🚀 合约部署的工作原理（即将推出）。

## 内存扩展
每当您引用一个内存地址`n`时，EVM将自动从`0`到`n`（包括`n`）分配任何尚未分配的内存。

换句话说，您使用的任何内存位置都会导致EVM确保其下方的所有内存位置也被分配。

这称为内存扩展。

分配的每个字节的内存会产生内存扩展的燃气成本。另一方面，重复使用已分配的内存不会产生内存扩展的燃气成本。

此外，您使用的内存越多，成本就越高。

您可以随时使用MSIZE操作码检查已分配的内存大小。

### 公式
内存扩展的燃气成本公式如下（注意，在此上下文中/表示整数除法）：

    扩展成本（字节）= words^2 / 512 + words * 3
      其中
        words =（字节+ 31）/ 32

    expansion_cost(bytes) = words^2 / 512 + words * 3
      where
        words = (bytes + 31) / 32

请注意，这假设没有分配任何内存。

为了适应先前分配的字节，您需要计算两次：一次用于总使用字节，一次用于先前总使用字节。

    实际成本（当前，先前）= 扩展成本（当前）- 扩展成本（先前）

    real_cost(current, prev) = expansion_cost(current) - expansion_cost(prev)

### 内存扩展示例1

    PUSH1 0x01
    PUSH1 0x40
    MSTORE

假设这是函数调用中运行的唯一字节码...

`MSTORE`操作导致EVM分配了总共96字节的内存。
- 尽管MSTORE只写入32字节，但在本例中它写入位置0x40，即内存位置64（十进制）。
- 我们引用的最高内存位置是0x5f，即十进制的95。这是因为我们从内存位置0x40开始写入32字节。
- 总体而言，此示例具有 $expansion\_cost(96) = 3^2 / 512 + 3 * 3 = 9 gas$ 燃气的内存扩展成本。

### 内存扩展示例2

    PUSH1 0x01
    PUSH1 0x20
    MSTORE

    PUSH1 0x02
    PUSH1 0x40
    MSTORE

假设这是函数调用中运行的唯一字节码...

`MSTORE`操作导致EVM分配了总共96字节（再次！）的内存。

尽管我们比前一个示例写入了32字节更多，但我们使用的最高内存位置仍然是0x5f。
因此，我们仍然只需支付总共96字节的内存扩展燃气成本。

## 使用内存的操作码
以下操作码访问内存，因此有可能扩展内存（从而产生内存扩展燃气成本）：

- 写入内存的操作码：
    - MSTORE / MSTORE8 - 将堆栈中的数据写入内存。
    - CALLDATACOPY - 将calldata中的数据复制到内存中。
    - CODECOPY - 将当前运行的合约的字节码复制到内存中。
    - EXTCODECOPY - 将外部合约地址的字节码复制到内存中。
    - RETURNDATACOPY - 将上次外部调用返回的数据复制到内存中。

- 读取内存的操作码：
    - MLOAD - 将32字节的内存复制到堆栈上。
    - RETURN - 返回指定的内存片段。
    - SHA3 - 对指定的内存片段执行keccak哈希，然后将结果放入堆栈。
    - LOG0 - LOG4 - 读取指定的内存片段，并将其作为事件的一部分发出。
    - REVERT - 以指定的内存片段作为还原消息进行还原。
    - CREATE / CREATE2 - 使用指定的内存片段作为新合约的部署字节码创建新合约。

- 既读又写的操作码：
    - CALL / STATICCALL / DELEGATECALL - 将内存片段作为calldata读取，调用外部合约，然后将返回的数据写入内存片段。

有关这些操作码的更多详细信息，请参阅wolflo的出色操作码参考页面。

## 结论
EVM使得与内存一起工作比大多数环境更简单。无需手动分配内存，每个函数调用都有自己独立的内存字符串。

许多操作码使用内存，了解与内存扩展相关的燃气成本对于管理燃气成本很重要。

最终，内存只是临时的。为了编写真正的程序，我们将需要持久数据，这将在下一章中介绍。




