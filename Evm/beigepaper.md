# beigepaper
[项目地址](https://github.com/chronaeon/beigepaper/blob/master/README.md)

用非黄皮书语法重写黄皮书。

该项目的存在是为了让更广泛的受众能够阅读以太坊黄皮书。这是测试版，因此存在勘误，并且仍在添加内容。

# 3. Processing and Computation（处理和计算）
## 3.7. Ethereum Virtual Machine
EVM（以太坊虚拟机）具有简单的基于堆栈的架构。机器的字长和堆栈大小为256位。这是为了方便Keccak-256散列方案和基于椭圆曲线的计算而选择的。内存模型是一个简单的字寻址字节数组。内存堆栈的最大大小为1024位。该机器还具有独立的存储模型；这个模型与内存类似，但不是字节数组，而是字寻址的字数组。与易失性的内存不同，存储是非易失性的，并作为系统状态的一部分进行维护。

初始状态下，存储和内存中的所有位置都被定义为零。该机器不遵循标准的冯·诺依曼架构。程序代码不是存储在通常可访问的内存或存储中，而是单独存储在一个虚拟的只能通过专用指令进行交互的只读存储器中（ROM）。

该机器可能会由于多种原因出现异常执行，包括堆栈下溢和无效指令。与燃气耗尽异常一样，这些异常也不会保持状态变化不变。相反，机器立即停止执行，并将问题报告给执行代理（事务处理器或递归地生成的执行环境），后者将单独处理该问题。

### 3.7.1. Fees
费用（以燃料计量）在三种不同情况下收取，这三种情况都是操作执行的先决条件。第一种也是最常见的情况是与操作计算本身相关的费用。其次，为了支付下属消息调用或合约创建的费用，可以从燃料中扣除；这构成了`CREATE`、`CALL`和`CALLCODE`操作的支付的一部分。最后，由于内存使用量的增加，可能需要支付燃料费用。

在账户执行过程中，用于内存使用的总费用与所需的32字节的最小倍数成比例，以确保所有内存索引（无论是读取还是写入）都包含在范围内。这是按需支付的；因此，引用比先前索引的内存区域大至少32字节的内存，肯定会导致额外的内存使用费用。由于这个费用，地址趋于超过32位边界的可能性极低。

实现必须能够应对这种情况。存储费用具有稍微微妙的行为，以激励尽量减少存储的使用（这直接对应于所有节点上的更大状态数据库），清除存储中条目的操作的执行费用不仅被免除，还会获得合格的退款；实际上，这个退款实际上是提前支付的，因为存储位置的初始使用成本远高于正常使用成本。

## 3.8. Execution
### 3.8.1. 内在有效性
内在有效性的标准如下：
- 交易遵循良好格式的RLP（递归长度前缀）规则。
- 交易上的签名有效。
- 交易上的nonce有效，即等于发送方账户的当前nonce。
- gas_limit大于或等于交易使用的内在_gas。
- 发送方账户余额包含了预付费所需的费用。

### 3.8.2. 交易收据
在执行过程中使用的gas数量和属于该交易的累积日志项被存储，而关于交易执行结果的信息则存储在交易收据tx_receipt中。通过执行交易创建的一组日志事件logs_set以及包含了这些日志事件实际信息的布隆过滤器logs_bloom也位于交易收据中。此外，交易收据还存储了包含交易收据的区块中使用的gas数量post(gas_used)以及交易后的状态post_transaction(state)。因此，交易收据是对任何给定执行的记录。

有效的交易执行始于对状态的永久性更改：发送方账户的nonce增加一个，余额减少一个名为collateral_gasa的抵押品，该抵押品是交易在执行之前需要支付的gas数量。如果消息调用或合约创建来自执行代码的合约账户，则原始交易者与发送方不同。

交易执行后，出现一个临时状态，即预终态。在将EVM操作码加入world_state之前，用于执行个别EVM操作码的gas会产生：
- 临时状态。
- 内在gas，和
- 相关的子状态。
- 标记为自毁的账户在交易完成后。self_destruct(accounts)
- logs_series，用于在前端应用程序中创建EVM代码执行的检查点，由tx_receipt中的logs_set和logs_bloom组成。
- 退款余额.

代码执行总是消耗gas。如果gas用尽，则会发出一条gas不足的错误信号（oog），并且结果状态将定义为空集；它对世界状态没有影响。这描述了以太坊的交易性质。为了影响世界状态，交易必须完全执行或完全不执行。

### 3.8.3. 代码存款
如果初始化代码成功完成，则支付最终的合约创建成本，即代码存款成本c，与创建的合约代码的大小成比例。

### 3.8.4. 执行模型

基础知识：以太坊的核心是基于栈的虚拟机，它执行计算机的各种操作。实际上，它是一个即时的运行时环境，在通过最终化函数将所有计算完成的结果添加到最终状态之前，执行多个子状态作为EVM计算实例。

除了系统状态和用于计算的剩余燃料之外，在执行环境中还有几个重要的信息，执行代理必须提供：
- account_address，正在执行代码的账户地址。
- sender_address，发起此执行的交易的发送者地址。
- originator_price，发起此执行的交易中的燃料价格。
- input_data，一个字节数组，是此执行的输入数据；如果执行代理是一个交易，那么这将是交易数据。
- account_address，导致代码执行的账户地址；如果执行代理是一个交易，那么这将是交易发送者。
- newstate_value，以Wei为单位，传递给此账户的值，如果执行代理是一个交易，那么这将是交易的价值。
- code数组，是要执行的机器代码的字节数组。
- block_header，当前区块的区块头。
- stack_depth，当前消息调用或合约创建的深度（即当前正在执行的CALL或CREATE的数量）。

执行模型定义了状态转换函数，该函数可以计算出结果状态、剩余的燃料、累计的子状态和结果输出，根据这些定义。在当前上下文中，我们将定义累计的子状态为自毁集合、日志序列、已触及账户和退款的元组。

### 3.8.5. 执行概述
在大多数实际的实现中，执行函数被建模为完整系统状态和机器状态的迭代进展的组合。它通过迭代函数的定义进行递归，迭代函数定义了状态机单个周期的结果，以及停机检查函数，该函数确定当前状态是否为机器的异常停机状态，以及如果当前状态为机器的控制停机状态时的指令输出数据。空序列表示执行应停止，而空集表示执行应继续。

在评估执行时，我们从结果机器状态中提取剩余的燃料。因此，它被循环（递归或迭代循环）直到异常停机变为真，表明当前状态异常，机器必须停机并丢弃任何更改，或者直到H成为序列（而不是空集），表明机器已达到控制停机状态。

机器状态被定义为一个元组，其中包括可用的燃料、程序计数器、内存内容、内存中活动单词的数量（从位置0开始连续计数）和堆栈内容。内存内容是一个大小为2256的零序列。

### 3.8.6. 执行周期
堆栈项从序列的最左侧、索引较低的部分添加或删除；所有其他项保持不变：燃料减少了指令的燃料成本，对于大多数指令，程序计数器在每个周期增加，对于三个例外情况，我们假设一个由两个指令下标的函数J，它的结果是相应的值：否则，通常假设内存、自毁集合和系统状态不会改变；然而，指令通常会改变这些值的一个或多个组成部分。

临时状态是在事务执行过程中生成的较小的临时状态。它包含三组数据。

### 3.8.7. 消息调用
消息调用可以来自交易或者合约代码的内部执行。它包含数据字段，其中包含用户输入到消息调用中的用户数据。消息允许账户之间的通信（无论是合约还是外部）。消息可以以msg_calls的形式给出输出数据。如果是合约账户，当账户接收到消息调用时，此代码将被执行。消息调用和合约创建都是交易，但是合约创建从不被视为消息调用。消息调用总是向另一个账户转移一定数量的价值。如果消息调用是一个账户创建交易，那么给定的价值将扮演对新账户的捐赠的角色。每当一个账户接收到消息调用时，它都会返回一个主体，这是由init函数触发的。用户数据以无限大小的字节数组的形式结构化输入到消息调用中。

通用的Gas消息调用总是有一个在Gas中达成一致的成本。合约创建交易和消息调用交易之间存在明显的区别。无论是合约创建还是消息调用所执行的计算都代表当前合法有效的状态。从这一点开始，不可能有无效的交易。还有一个消息调用/合约创建堆栈。这个堆栈有一个深度，取决于其中有多少个交易。合约创建和消息调用在执行方式上完全不同，并且在以太坊中扮演完全不同的角色。这些概念可能会混淆。消息调用可能导致在下一个状态而不是当前状态中发生的计算。如果当前正在执行的账户接收到一个消息调用，那么不会执行任何代码，因为该账户可能存在，但尚未有代码。要执行一个消息调用交易，需要以下内容：

- 发送者
- 交易发起者
- 接收者
- 账户（通常与接收者相同）
- 可用的Gas
- 价值
- Gas价格
- 任意长度的字节数组
- 消息调用/合约创建堆栈的当前深度。

### 3.8.8. 合约创建
要启动合约创建，您需要向空地址发送交易。这将执行init并返回body。init仅在账户创建时执行一次，并在此后永久丢弃。

### 3.8.9. 执行环境
以太坊运行环境是自主对象在EVM中执行的环境：EVM作为该环境的一部分运行。

### 3.8.10. 大端函数
该函数将正整数值扩展为最小长度的大端字节数组。当与·操作符一起使用时，它表示序列连接。
大端函数与RLP序列化和反序列化一起使用。