# beigepaper
[项目地址](https://github.com/chronaeon/beigepaper/blob/master/README.md)

用非黄皮书语法重写黄皮书。

该项目的存在是为了让更广泛的受众能够阅读以太坊黄皮书。这是测试版，因此存在勘误，并且仍在添加内容。

# 3. Processing and Computation（处理和计算）
## 3.7. Ethereum Virtual Machine
EVM（以太坊虚拟机）具有简单的基于堆栈的架构。机器的字长和堆栈大小为256位。这是为了方便Keccak-256散列方案和基于椭圆曲线的计算而选择的。内存模型是一个简单的字寻址字节数组。内存堆栈的最大大小为1024位。该机器还具有独立的存储模型；这个模型与内存类似，但不是字节数组，而是字寻址的字数组。与易失性的内存不同，存储是非易失性的，并作为系统状态的一部分进行维护。

初始状态下，存储和内存中的所有位置都被定义为零。该机器不遵循标准的冯·诺依曼架构。程序代码不是存储在通常可访问的内存或存储中，而是单独存储在一个虚拟的只能通过专用指令进行交互的只读存储器中（ROM）。

该机器可能会由于多种原因出现异常执行，包括堆栈下溢和无效指令。与燃气耗尽异常一样，这些异常也不会保持状态变化不变。相反，机器立即停止执行，并将问题报告给执行代理（事务处理器或递归地生成的执行环境），后者将单独处理该问题。

### 3.7.1. Fees
费用（以燃料计量）在三种不同情况下收取，这三种情况都是操作执行的先决条件。第一种也是最常见的情况是与操作计算本身相关的费用。其次，为了支付下属消息调用或合约创建的费用，可以从燃料中扣除；这构成了`CREATE`、`CALL`和`CALLCODE`操作的支付的一部分。最后，由于内存使用量的增加，可能需要支付燃料费用。

在账户执行过程中，用于内存使用的总费用与所需的32字节的最小倍数成比例，以确保所有内存索引（无论是读取还是写入）都包含在范围内。这是按需支付的；因此，引用比先前索引的内存区域大至少32字节的内存，肯定会导致额外的内存使用费用。由于这个费用，地址趋于超过32位边界的可能性极低。

实现必须能够应对这种情况。存储费用具有稍微微妙的行为，以激励尽量减少存储的使用（这直接对应于所有节点上的更大状态数据库），清除存储中条目的操作的执行费用不仅被免除，还会获得合格的退款；实际上，这个退款实际上是提前支付的，因为存储位置的初始使用成本远高于正常使用成本。

## 3.8. Execution
### 3.8.1. 内在有效性
内在有效性的标准如下：
- 交易遵循良好格式的RLP（递归长度前缀）规则。
- 交易上的签名有效。
- 交易上的nonce有效，即等于发送方账户的当前nonce。
- gas_limit大于或等于交易使用的内在_gas。
- 发送方账户余额包含了预付费所需的费用。

### 3.8.2. 交易收据
在执行过程中使用的gas数量和属于该交易的累积日志项被存储，而关于交易执行结果的信息则存储在交易收据tx_receipt中。通过执行交易创建的一组日志事件logs_set以及包含了这些日志事件实际信息的布隆过滤器logs_bloom也位于交易收据中。此外，交易收据还存储了包含交易收据的区块中使用的gas数量post(gas_used)以及交易后的状态post_transaction(state)。因此，交易收据是对任何给定执行的记录。

有效的交易执行始于对状态的永久性更改：发送方账户的nonce增加一个，余额减少一个名为collateral_gasa的抵押品，该抵押品是交易在执行之前需要支付的gas数量。如果消息调用或合约创建来自执行代码的合约账户，则原始交易者与发送方不同。

交易执行后，出现一个临时状态，即预终态。在将EVM操作码加入world_state之前，用于执行个别EVM操作码的gas会产生：
- 临时状态。
- 内在gas，和
- 相关的子状态。
- 标记为自毁的账户在交易完成后。self_destruct(accounts)
- logs_series，用于在前端应用程序中创建EVM代码执行的检查点，由tx_receipt中的logs_set和logs_bloom组成。
- 退款余额.

代码执行总是消耗gas。如果gas用尽，则会发出一条gas不足的错误信号（oog），并且结果状态将定义为空集；它对世界状态没有影响。这描述了以太坊的交易性质。为了影响世界状态，交易必须完全执行或完全不执行。

### 3.8.3. 代码存款
如果初始化代码成功完成，则支付最终的合约创建成本，即代码存款成本c，与创建的合约代码的大小成比例。








