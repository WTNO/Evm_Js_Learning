# 以太坊虚拟机
在以太坊协议和操作的中心，是以太坊虚拟机，简称EVM。正如你从名字中可能猜到的，它是一个计算引擎，与微软的.NET框架的虚拟机，或者其他字节码编译的编程语言的解释器并没有太大的不同。在这一章中，我们将详细地研究EVM，包括它的指令集，结构和操作，以及在以太坊状态更新的上下文中。

## 什么是EVM？
EVM是以太坊处理智能合约部署和执行的部分。从一个EOA（外部拥有账户）到另一个EOA的简单值转移交易，实际上不需要涉及到它，但是其他所有事情都将涉及到由EVM计算的状态更新。从高级角度来看，运行在以太坊区块链上的EVM可以被视为一个全球分散的计算机，包含数百万个可执行对象，每个对象都有自己的永久数据存储。

EVM是一个准图灵完备的状态机器；"准"是因为所有的执行过程都被可用于任何给定的智能合约执行的gas数量限制在有限的计算步骤内。因此，停机问题得到了"解决"（所有程序执行将停止），并且避免了执行可能（无意或恶意）永远运行，从而使整个以太坊平台停止的情况。

EVM具有基于堆栈的架构，将所有内存值存储在堆栈上。它的字大小为256位（主要是为了方便本地哈希和椭圆曲线操作），并具有几个可寻址的数据组件：
- 一个不可变的程序代码ROM，加载了要执行的智能合约的字节码
- 一个易失性内存，每个位置都被明确初始化为零
- 一个作为以太坊状态部分的永久存储，也初始化为零

在执行期间还有一组环境变量和数据可用。我们将在本章后面详细介绍这些。

下图显示了EVM的架构和执行上下文：

![img](img/evm-architecture.png '图1. 以太坊虚拟机(EVM)架构和执行上下文')  

### 与现有技术的比较
"虚拟机"这个术语通常用来描述对真实计算机的虚拟化，典型的方式是通过"超级管理程序"，如VirtualBox或QEMU，或者是对整个操作系统实例的虚拟化，比如Linux的KVM。这些都需要提供一个软件抽象，分别对应实际硬件，以及系统调用和其他内核功能的抽象。

EVM（以太坊虚拟机）的运作领域则要小得多：它只是一个计算引擎，因此只提供计算和存储的抽象，类似于Java虚拟机(JVM)的规范。从高层视角来看，JVM旨在提供一个与底层主机操作系统或硬件无关的运行环境，以实现在各种系统中的兼容性。高级编程语言如Java或Scala（使用JVM）或C#（使用.NET）都会被编译成各自虚拟机的字节码指令集。同样，EVM执行自己的字节码指令集（在下一节中描述），高级智能合约编程语言如LLL、Serpent、Mutan或Solidity都会被编译成这种形式。

因此，EVM没有调度能力，因为执行顺序是由外部组织的——以太坊客户端通过验证区块交易来确定需要执行哪些智能合约以及执行的顺序。在这个意义上，以太坊的世界计算机是单线程的，就像JavaScript一样。EVM也没有任何"系统接口"处理或“硬件支持”，因为没有物理机器需要接口。以太坊的世界计算机完全是虚拟的。

### EVM指令集（字节码操作）
EVM指令集提供了你可能期望的大部分操作，包括：
- 算术和位逻辑操作
- 执行上下文查询
- 堆栈，内存和存储访问
- 控制流操作
- 日志记录，调用和其他操作符

除了典型的字节码操作，EVM还可以访问账户信息（例如，地址和余额）和块信息（例如，块号和当前气体价格）。

让我们通过查看可用的操作码及其功能，更详细地开始探索EVM。如你所料，所有操作数都来自堆栈，结果（如果适用）通常会放回堆栈顶部。


> 注意  
> 在[evm_opcodes]中可以找到操作码及其相应的气体成本的完整列表。

可用的操作码可以分为以下几类：

#### 算术运算
算术操作码指令：

    ADD        //将栈顶的两个元素相加
    MUL        //将栈顶的两个元素相乘
    SUB        //将栈顶的两个元素相减
    DIV        //整数除法
    SDIV       //有符号整数除法
    MOD        //模（余数）运算
    SMOD       //有符号模运算
    ADDMOD     //对任何数进行模加运算
    MULMOD     //对任何数进行模乘运算
    EXP        //指数运算
    SIGNEXTEND //扩展二进制补码有符号整数的长度
    SHA3       //计算一块内存的Keccak-256哈希值

> 注意，除非另有说明，所有的算术运算都是以${2^{256}}$为模进行的，且零的零次方，${0^0}$，被认为是1。

#### 栈操作
栈，内存和存储管理指令：

    POP     //从栈顶移除项目
    MLOAD   //从内存中加载一个字
    MSTORE  //保存一个字到内存
    MSTORE8 //保存一个字节到内存
    SLOAD   //从存储中加载一个字
    SSTORE  //保存一个字到存储
    MSIZE   //获取活动内存的大小（以字节为单位）
    PUSHx   //将x字节项目放在栈上，其中x可以是
            // 1到32（完整字）包含的任何整数
    DUPx    //复制第x个栈项目，其中x可以是
            // 1到16包含的任何整数
    SWAPx   //交换第1个和（x+1）-th栈项目，其中x可以是
            // 1到16包含的任何整数

#### 流程控制操作
控制流程的指令：

    STOP      //停止执行
    JUMP      //将程序计数器设置为任意值
    JUMPI     //有条件地改变程序计数器
    PC        //获取程序计数器的值（在对应于此指令的增量之前）
    JUMPDEST  //标记跳转的有效目标















