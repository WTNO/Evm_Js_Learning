# 以太坊虚拟机
在以太坊协议和操作的中心，是以太坊虚拟机，简称EVM。正如你从名字中可能猜到的，它是一个计算引擎，与微软的.NET框架的虚拟机，或者其他字节码编译的编程语言的解释器并没有太大的不同。在这一章中，我们将详细地研究EVM，包括它的指令集，结构和操作，以及在以太坊状态更新的上下文中。

## 什么是EVM？
EVM是以太坊处理智能合约部署和执行的部分。从一个EOA（外部拥有账户）到另一个EOA的简单值转移交易，实际上不需要涉及到它，但是其他所有事情都将涉及到由EVM计算的状态更新。从高级角度来看，运行在以太坊区块链上的EVM可以被视为一个全球分散的计算机，包含数百万个可执行对象，每个对象都有自己的永久数据存储。

EVM是一个准图灵完备的状态机器；"准"是因为所有的执行过程都被可用于任何给定的智能合约执行的gas数量限制在有限的计算步骤内。因此，停机问题得到了"解决"（所有程序执行将停止），并且避免了执行可能（无意或恶意）永远运行，从而使整个以太坊平台停止的情况。

EVM具有基于堆栈的架构，将所有内存值存储在堆栈上。它的字大小为256位（主要是为了方便本地哈希和椭圆曲线操作），并具有几个可寻址的数据组件：
- 一个不可变的程序代码ROM，加载了要执行的智能合约的字节码
- 一个易失性内存，每个位置都被明确初始化为零
- 一个作为以太坊状态部分的永久存储，也初始化为零

在执行期间还有一组环境变量和数据可用。我们将在本章后面详细介绍这些。

下图显示了EVM的架构和执行上下文：

![img](img/evm-architecture.png '图1. 以太坊虚拟机(EVM)架构和执行上下文')  

### 与现有技术的比较
"虚拟机"这个术语通常用来描述对真实计算机的虚拟化，典型的方式是通过"超级管理程序"，如VirtualBox或QEMU，或者是对整个操作系统实例的虚拟化，比如Linux的KVM。这些都需要提供一个软件抽象，分别对应实际硬件，以及系统调用和其他内核功能的抽象。

EVM（以太坊虚拟机）的运作领域则要小得多：它只是一个计算引擎，因此只提供计算和存储的抽象，类似于Java虚拟机(JVM)的规范。从高层视角来看，JVM旨在提供一个与底层主机操作系统或硬件无关的运行环境，以实现在各种系统中的兼容性。高级编程语言如Java或Scala（使用JVM）或C#（使用.NET）都会被编译成各自虚拟机的字节码指令集。同样，EVM执行自己的字节码指令集（在下一节中描述），高级智能合约编程语言如LLL、Serpent、Mutan或Solidity都会被编译成这种形式。

因此，EVM没有调度能力，因为执行顺序是由外部组织的——以太坊客户端通过验证区块交易来确定需要执行哪些智能合约以及执行的顺序。在这个意义上，以太坊的世界计算机是单线程的，就像JavaScript一样。EVM也没有任何"系统接口"处理或“硬件支持”，因为没有物理机器需要接口。以太坊的世界计算机完全是虚拟的。

### EVM指令集（字节码操作）
EVM指令集提供了你可能期望的大部分操作，包括：
- 算术和位逻辑操作
- 执行上下文查询
- 堆栈，内存和存储访问
- 控制流操作
- 日志记录，调用和其他操作符

除了典型的字节码操作，EVM还可以访问账户信息（例如，地址和余额）和块信息（例如，块号和当前气体价格）。

让我们通过查看可用的操作码及其功能，更详细地开始探索EVM。如你所料，所有操作数都来自堆栈，结果（如果适用）通常会放回堆栈顶部。


> 注意  
> 在[evm_opcodes]中可以找到操作码及其相应的气体成本的完整列表。

可用的操作码可以分为以下几类：

#### 算术运算
算术操作码指令：

    ADD        //将栈顶的两个元素相加
    MUL        //将栈顶的两个元素相乘
    SUB        //将栈顶的两个元素相减
    DIV        //整数除法
    SDIV       //有符号整数除法
    MOD        //模（余数）运算
    SMOD       //有符号模运算
    ADDMOD     //对任何数进行模加运算
    MULMOD     //对任何数进行模乘运算
    EXP        //指数运算
    SIGNEXTEND //扩展二进制补码有符号整数的长度
    SHA3       //计算一块内存的Keccak-256哈希值

> 注意，除非另有说明，所有的算术运算都是以${2^{256}}$为模进行的，且零的零次方，${0^0}$，被认为是1。

#### 栈操作
栈，内存和存储管理指令：

    POP     //从栈顶移除项目
    MLOAD   //从内存中加载一个字
    MSTORE  //保存一个字到内存
    MSTORE8 //保存一个字节到内存
    SLOAD   //从存储中加载一个字
    SSTORE  //保存一个字到存储
    MSIZE   //获取活动内存的大小（以字节为单位）
    PUSHx   //将x字节项目放在栈上，其中x可以是
            // 1到32（完整字）包含的任何整数
    DUPx    //复制第x个栈项目，其中x可以是
            // 1到16包含的任何整数
    SWAPx   //交换第1个和（x+1）-th栈项目，其中x可以是
            // 1到16包含的任何整数

#### 流程控制操作
控制流程的指令：

    STOP      //停止执行
    JUMP      //将程序计数器设置为任意值
    JUMPI     //有条件地改变程序计数器
    PC        //获取程序计数器的值（在对应于此指令的增量之前）
    JUMPDEST  //标记跳转的有效目标

#### 系统操作
程序执行的操作码：

    LOGx          //添加一个带有x主题的日志记录，其中x是从0到4的任何整数
    CREATE        //创建一个带有关联代码的新账户
    CALL          //消息调用进入另一个账户，即运行另一个账户的代码
    CALLCODE      //使用另一个账户的代码，消息调用进入此账户
    RETURN        //停止执行并返回输出数据
    DELEGATECALL  //使用替代账户的代码，消息调用进入此账户，但保留当前的发送者和值
    STATICCALL    //静态消息调用进入一个账户
    REVERT        //停止执行，撤销状态更改，但返回数据和剩余的gas
    INVALID       //指定的无效指令
    SELFDESTRUCT  //停止执行并注册账户以供删除

#### 逻辑操作
比较和位运算逻辑的操作码：

    LT     //小于比较
    GT     //大于比较
    SLT    //有符号的小于比较
    SGT    //有符号的大于比较
    EQ     //等于比较
    ISZERO //简单的NOT运算符
    AND    //位与运算
    OR     //位或运算
    XOR    //位异或运算
    NOT    //位非运算
    BYTE   //从全宽256位字中检索一个单字节

#### 环境操作
处理执行环境信息的操作码：

    GAS            //获取可用的gas量（减去此指令的减量）
    ADDRESS        //获取当前执行账户的地址
    BALANCE        //获取任何给定账户的账户余额
    ORIGIN         //获取启动此EVM执行的EOA的地址
    CALLER         //获取直接负责此执行的调用者的地址
    CALLVALUE      //获取负责此执行的调用者存入的以太币数量
    CALLDATALOAD   //获取负责此执行的调用者发送的输入数据
    CALLDATASIZE   //获取输入数据的大小
    CALLDATACOPY   //将输入数据复制到内存
    CODESIZE       //获取当前环境中运行的代码的大小
    CODECOPY       //将当前环境中运行的代码复制到内存
    GASPRICE       //获取原始交易指定的gas价格
    EXTCODESIZE    //获取任何账户代码的大小
    EXTCODECOPY    //将任何账户的代码复制到内存
    RETURNDATASIZE //获取当前环境中上一次调用的输出数据的大小
    RETURNDATACOPY //将上一次调用的数据输出复制到内存

#### 区块操作
用于访问当前区块信息的操作码：

    BLOCKHASH  //获取最近完成的256个区块之一的哈希值
    COINBASE   //获取区块奖励的区块受益人地址
    TIMESTAMP  //获取区块的时间戳
    NUMBER     //获取区块的编号
    DIFFICULTY //获取区块的难度
    GASLIMIT   //获取区块的气体限制

### 以太坊状态
EVM的任务是通过计算由以太坊协议定义的智能合约代码执行产生的有效状态转换来更新以太坊的状态。这一点使得以太坊被描述为基于交易的状态机，这反映了外部参与者（即账户持有人和矿工）通过创建、接受和排序交易来启动状态转换的事实。在这一点上，有必要考虑什么构成了以太坊的状态。

在顶层，我们有以太坊的世界状态。世界状态是以太坊地址（160位值）到账户的映射。在较低的层次，每个以太坊地址代表一个账户，包括一个以太币余额（以该账户拥有的wei数量存储）、一个随机数（如果是EOA，代表从此账户成功发送的交易数量，如果是合约账户，代表由它创建的合约数量）、账户的存储（这是一个永久的数据存储，仅由智能合约使用），以及账户的程序代码（再次强调，只有当账户是智能合约账户时才有）。一个EOA总是没有代码和空的存储。

当交易导致智能合约代码执行时，一个EVM会被实例化，包含所有关于正在创建的当前区块和正在处理的特定交易的信息。特别是，EVM的程序代码ROM被加载了被调用的合约账户的代码，程序计数器被设置为零，存储从合约账户的存储中加载，内存被设置为全零，所有的区块和环境变量被设置。一个关键变量是这个执行的气体供应，它被设置为交易开始时发件人支付的气体数量（参见Gas以获取更多详细信息）。随着代码执行的进行，气体供应根据已执行操作的气体成本而减少。如果在任何时候气体供应减少到零，我们就会得到一个"Out of Gas"（OOG）异常；执行立即停止，交易被放弃。除了发件人的随机数增加和他们的以太币余额下降以支付给区块的受益人用于执行代码到停止点的资源外，对以太坊状态的任何改变都不会被应用。在这一点上，你可以认为EVM在以太坊世界状态的一个沙盒副本上运行，如果出于任何原因无法完成执行，这个沙盒版本将完全被丢弃。然而，如果执行成功完成，那么真实世界的状态将被更新以匹配沙盒版本，包括对被调用合约的存储数据的任何改变，任何新创建的合约，以及任何启动的以太币余额转移。

注意，因为智能合约本身可以有效地启动交易，代码执行是一个递归的过程。一个合约可以调用其他合约，每个调用都会导致另一个EVM被实例化，围绕新的调用目标。每个实例都有其沙盒世界状态从上一级EVM的沙盒中初始化。每个实例也被给定了一定数量的气体供应（当然，不超过上一级剩余的气体数量），因此可能会因为被给予的气体过少而无法完成其执行，自身也会中断并出现异常。再次强调，在这种情况下，沙盒状态被丢弃，执行返回到上一级的EVM。

### 将Solidity编译为EVM字节码
将Solidity源文件编译为EVM字节码可以通过几种方法完成。在[intro_chapter]中，我们使用了在线的Remix编译器。在本章中，我们将在命令行使用solc执行文件。要获取选项列表，请运行以下命令：

    $ solc --help

用`--opcodes`命令行选项轻松生成Solidity源文件的原始操作码流。这个操作码流省略了一些信息（`--asm`选项产生完整信息），但对于此讨论足够了。例如，编译一个示例Solidity文件，Example.sol，并将操作码输出发送到名为BytecodeDir的目录，可以使用以下命令完成：

    $ solc -o BytecodeDir --opcodes Example.sol

或者：

    $ solc -o BytecodeDir --asm Example.sol

以下命令将为我们的示例程序生成字节码二进制文件：

    $ solc -o BytecodeDir --bin Example.sol

生成的输出操作码文件将取决于Solidity源文件中包含的特定合约。我们的简单Solidity文件Example.sol只有一个名为example的合约：

    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;

    contract example {
        address contractOwner;

        constructor() {
            contractOwner = msg.sender;
        }
    }

如你所见，这个合约只做一件事，就是持有一个持久状态变量，该变量被设置为最后一个运行这个合约的帐户地址。

如果你在BytecodeDir目录中查看，你会看到opcode文件example.opcode，它包含了示例合约的EVM操作码指令。在文本编辑器中打开example.opcode文件，你会看到以下内容：

    PUSH1 0x80
    PUSH1 0x40
    MSTORE
    CALLVALUE
    DUP
    ISZERO
    PUSH1 0x0f
    JUMPI
    PUSH1 0x00
    DUP
    REVERT
    JUMPDEST
    POP
    CALLER
    PUSH1 0x00
    DUP
    PUSH2 0x0100
    EXP
    DUP
    SLOAD
    DUP
    PUSH20 0xffffffffffffffffffffffffffffffffffffffff
    MUL
    NOT
    AND
    SWAP
    DUP
    PUSH20 0xffffffffffffffffffffffffffffffffffffffff
    AND
    MUL
    OR
    SWAP
    SSTORE
    POP
    PUSH1 0x3f
    DUP
    PUSH1 0x5d
    PUSH1 0x00
    CODECOPY
    PUSH1 0x00
    RETURN
    INVALID
    PUSH1 0x80
    PUSH1 0x40
    MSTORE
    PUSH1 0x00
    DUP
    REVERT
    INVALID
    LOG
    PUSH5 0x6970667358

    6080604052348015600f57600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550603f80605d6000396000f3fe6080604052600080fdfea26469706673582212204669e46eddbfe5681422f2d4c246b227e655b48c20fe641f2f6c2ec7bdba986264736f6c63430008070033





