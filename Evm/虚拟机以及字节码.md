# 以太坊虚拟机
在以太坊协议和操作的中心，是以太坊虚拟机，简称EVM。正如你从名字中可能猜到的，它是一个计算引擎，与微软的.NET框架的虚拟机，或者其他字节码编译的编程语言的解释器并没有太大的不同。在这一章中，我们将详细地研究EVM，包括它的指令集，结构和操作，以及在以太坊状态更新的上下文中。

## 什么是EVM？
EVM是以太坊处理智能合约部署和执行的部分。从一个EOA（外部拥有账户）到另一个EOA的简单值转移交易，实际上不需要涉及到它，但是其他所有事情都将涉及到由EVM计算的状态更新。从高级角度来看，运行在以太坊区块链上的EVM可以被视为一个全球分散的计算机，包含数百万个可执行对象，每个对象都有自己的永久数据存储。

EVM是一个准图灵完备的状态机器；"准"是因为所有的执行过程都被可用于任何给定的智能合约执行的gas数量限制在有限的计算步骤内。因此，停机问题得到了"解决"（所有程序执行将停止），并且避免了执行可能（无意或恶意）永远运行，从而使整个以太坊平台停止的情况。

EVM具有基于堆栈的架构，将所有内存值存储在堆栈上。它的字大小为256位（主要是为了方便本地哈希和椭圆曲线操作），并具有几个可寻址的数据组件：
- 一个不可变的程序代码ROM，加载了要执行的智能合约的字节码
- 一个易失性内存，每个位置都被明确初始化为零
- 一个作为以太坊状态部分的永久存储，也初始化为零

在执行期间还有一组环境变量和数据可用。我们将在本章后面详细介绍这些。

下图显示了EVM的架构和执行上下文：

![img](img/evm-architecture.png '图1. 以太坊虚拟机(EVM)架构和执行上下文')  

### 与现有技术的比较
"虚拟机"这个术语通常用来描述对真实计算机的虚拟化，典型的方式是通过"超级管理程序"，如VirtualBox或QEMU，或者是对整个操作系统实例的虚拟化，比如Linux的KVM。这些都需要提供一个软件抽象，分别对应实际硬件，以及系统调用和其他内核功能的抽象。

EVM（以太坊虚拟机）的运作领域则要小得多：它只是一个计算引擎，因此只提供计算和存储的抽象，类似于Java虚拟机(JVM)的规范。从高层视角来看，JVM旨在提供一个与底层主机操作系统或硬件无关的运行环境，以实现在各种系统中的兼容性。高级编程语言如Java或Scala（使用JVM）或C#（使用.NET）都会被编译成各自虚拟机的字节码指令集。同样，EVM执行自己的字节码指令集（在下一节中描述），高级智能合约编程语言如LLL、Serpent、Mutan或Solidity都会被编译成这种形式。

因此，EVM没有调度能力，因为执行顺序是由外部组织的——以太坊客户端通过验证区块交易来确定需要执行哪些智能合约以及执行的顺序。在这个意义上，以太坊的世界计算机是单线程的，就像JavaScript一样。EVM也没有任何"系统接口"处理或“硬件支持”，因为没有物理机器需要接口。以太坊的世界计算机完全是虚拟的。

### EVM指令集（字节码操作）
EVM指令集提供了你可能期望的大部分操作，包括：
- 算术和位逻辑操作
- 执行上下文查询
- 堆栈，内存和存储访问
- 控制流操作
- 日志记录，调用和其他操作符

除了典型的字节码操作，EVM还可以访问账户信息（例如，地址和余额）和块信息（例如，块号和当前气体价格）。

让我们通过查看可用的操作码及其功能，更详细地开始探索EVM。如你所料，所有操作数都来自堆栈，结果（如果适用）通常会放回堆栈顶部。


> 注意  
> 在[evm_opcodes]中可以找到操作码及其相应的气体成本的完整列表。

可用的操作码可以分为以下几类：

#### 算术运算
算术操作码指令：

    ADD        //将栈顶的两个元素相加
    MUL        //将栈顶的两个元素相乘
    SUB        //将栈顶的两个元素相减
    DIV        //整数除法
    SDIV       //有符号整数除法
    MOD        //模（余数）运算
    SMOD       //有符号模运算
    ADDMOD     //对任何数进行模加运算
    MULMOD     //对任何数进行模乘运算
    EXP        //指数运算
    SIGNEXTEND //扩展二进制补码有符号整数的长度
    SHA3       //计算一块内存的Keccak-256哈希值

> 注意，除非另有说明，所有的算术运算都是以${2^{256}}$为模进行的，且零的零次方，${0^0}$，被认为是1。

#### 栈操作
栈，内存和存储管理指令：

    POP     //从栈顶移除项目
    MLOAD   //从内存中加载一个字
    MSTORE  //保存一个字到内存
    MSTORE8 //保存一个字节到内存
    SLOAD   //从存储中加载一个字
    SSTORE  //保存一个字到存储
    MSIZE   //获取活动内存的大小（以字节为单位）
    PUSHx   //将x字节项目放在栈上，其中x可以是
            // 1到32（完整字）包含的任何整数
    DUPx    //复制第x个栈项目，其中x可以是
            // 1到16包含的任何整数
    SWAPx   //交换第1个和（x+1）-th栈项目，其中x可以是
            // 1到16包含的任何整数

#### 流程控制操作
控制流程的指令：

    STOP      //停止执行
    JUMP      //将程序计数器设置为任意值
    JUMPI     //有条件地改变程序计数器
    PC        //获取程序计数器的值（在对应于此指令的增量之前）
    JUMPDEST  //标记跳转的有效目标

#### 系统操作
程序执行的操作码：

    LOGx          //添加一个带有x主题的日志记录，其中x是从0到4的任何整数
    CREATE        //创建一个带有关联代码的新账户
    CALL          //消息调用进入另一个账户，即运行另一个账户的代码
    CALLCODE      //使用另一个账户的代码，消息调用进入此账户
    RETURN        //停止执行并返回输出数据
    DELEGATECALL  //使用替代账户的代码，消息调用进入此账户，但保留当前的发送者和值
    STATICCALL    //静态消息调用进入一个账户
    REVERT        //停止执行，撤销状态更改，但返回数据和剩余的gas
    INVALID       //指定的无效指令
    SELFDESTRUCT  //停止执行并注册账户以供删除

#### 逻辑操作
比较和位运算逻辑的操作码：

    LT     //小于比较
    GT     //大于比较
    SLT    //有符号的小于比较
    SGT    //有符号的大于比较
    EQ     //等于比较
    ISZERO //简单的NOT运算符
    AND    //位与运算
    OR     //位或运算
    XOR    //位异或运算
    NOT    //位非运算
    BYTE   //从全宽256位字中检索一个单字节

#### 环境操作
处理执行环境信息的操作码：

    GAS            //获取可用的gas量（减去此指令的减量）
    ADDRESS        //获取当前执行账户的地址
    BALANCE        //获取任何给定账户的账户余额
    ORIGIN         //获取启动此EVM执行的EOA的地址
    CALLER         //获取直接负责此执行的调用者的地址
    CALLVALUE      //获取负责此执行的调用者存入的以太币数量
    CALLDATALOAD   //获取负责此执行的调用者发送的输入数据
    CALLDATASIZE   //获取输入数据的大小
    CALLDATACOPY   //将输入数据复制到内存
    CODESIZE       //获取当前环境中运行的代码的大小
    CODECOPY       //将当前环境中运行的代码复制到内存
    GASPRICE       //获取原始交易指定的gas价格
    EXTCODESIZE    //获取任何账户代码的大小
    EXTCODECOPY    //将任何账户的代码复制到内存
    RETURNDATASIZE //获取当前环境中上一次调用的输出数据的大小
    RETURNDATACOPY //将上一次调用的数据输出复制到内存

#### 区块操作
用于访问当前区块信息的操作码：

    BLOCKHASH  //获取最近完成的256个区块之一的哈希值
    COINBASE   //获取区块奖励的区块受益人地址
    TIMESTAMP  //获取区块的时间戳
    NUMBER     //获取区块的编号
    DIFFICULTY //获取区块的难度
    GASLIMIT   //获取区块的气体限制

### 以太坊状态
EVM的任务是通过计算由以太坊协议定义的智能合约代码执行产生的有效状态转换来更新以太坊的状态。这一点使得以太坊被描述为基于交易的状态机，这反映了外部参与者（即账户持有人和矿工）通过创建、接受和排序交易来启动状态转换的事实。在这一点上，有必要考虑什么构成了以太坊的状态。

在顶层，我们有以太坊的世界状态。世界状态是以太坊地址（160位值）到账户的映射。在较低的层次，每个以太坊地址代表一个账户，包括一个以太币余额（以该账户拥有的wei数量存储）、一个随机数（如果是EOA，代表从此账户成功发送的交易数量，如果是合约账户，代表由它创建的合约数量）、账户的存储（这是一个永久的数据存储，仅由智能合约使用），以及账户的程序代码（再次强调，只有当账户是智能合约账户时才有）。一个EOA总是没有代码和空的存储。

当交易导致智能合约代码执行时，一个EVM会被实例化，包含所有关于正在创建的当前区块和正在处理的特定交易的信息。特别是，EVM的程序代码ROM被加载了被调用的合约账户的代码，程序计数器被设置为零，存储从合约账户的存储中加载，内存被设置为全零，所有的区块和环境变量被设置。一个关键变量是这个执行的气体供应，它被设置为交易开始时发件人支付的气体数量（参见Gas以获取更多详细信息）。随着代码执行的进行，气体供应根据已执行操作的气体成本而减少。如果在任何时候气体供应减少到零，我们就会得到一个"Out of Gas"（OOG）异常；执行立即停止，交易被放弃。除了发件人的随机数增加和他们的以太币余额下降以支付给区块的受益人用于执行代码到停止点的资源外，对以太坊状态的任何改变都不会被应用。在这一点上，你可以认为EVM在以太坊世界状态的一个沙盒副本上运行，如果出于任何原因无法完成执行，这个沙盒版本将完全被丢弃。然而，如果执行成功完成，那么真实世界的状态将被更新以匹配沙盒版本，包括对被调用合约的存储数据的任何改变，任何新创建的合约，以及任何启动的以太币余额转移。

注意，因为智能合约本身可以有效地启动交易，代码执行是一个递归的过程。一个合约可以调用其他合约，每个调用都会导致另一个EVM被实例化，围绕新的调用目标。每个实例都有其沙盒世界状态从上一级EVM的沙盒中初始化。每个实例也被给定了一定数量的气体供应（当然，不超过上一级剩余的气体数量），因此可能会因为被给予的气体过少而无法完成其执行，自身也会中断并出现异常。再次强调，在这种情况下，沙盒状态被丢弃，执行返回到上一级的EVM。

### 将Solidity编译为EVM字节码
将Solidity源文件编译为EVM字节码可以通过几种方法完成。在[intro_chapter]中，我们使用了在线的Remix编译器。在本章中，我们将在命令行使用solc执行文件。要获取选项列表，请运行以下命令：

    $ solc --help

用`--opcodes`命令行选项轻松生成Solidity源文件的原始操作码流。这个操作码流省略了一些信息（`--asm`选项产生完整信息），但对于此讨论足够了。例如，编译一个示例Solidity文件，Example.sol，并将操作码输出发送到名为BytecodeDir的目录，可以使用以下命令完成：

    $ solc -o BytecodeDir --opcodes Example.sol

或者：

    $ solc -o BytecodeDir --asm Example.sol

以下命令将为我们的示例程序生成字节码二进制文件：

    $ solc -o BytecodeDir --bin Example.sol

生成的输出操作码文件将取决于Solidity源文件中包含的特定合约。我们的简单Solidity文件Example.sol只有一个名为example的合约：

    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;

    contract example {
        address contractOwner;

        constructor() {
            contractOwner = msg.sender;
        }
    }

如你所见，这个合约只做一件事，就是持有一个持久状态变量，该变量被设置为最后一个运行这个合约的帐户地址。

如果你在BytecodeDir目录中查看，你会看到opcode文件example.opcode，它包含了示例合约的EVM操作码指令。在文本编辑器中打开example.opcode文件，你会看到以下内容：

    .code
    000  PUSH1 0x80
    002  PUSH1 0x40
    004  MSTORE
    005  CALLVALUE
    006  DUP1
    007  ISZERO
    008  PUSH1 0x0f
    010  JUMPI
    011  PUSH1 0x00
    013  DUP1
    014  REVERT
    015  JUMPDEST
    016  POP
    017  CALLER
    018  PUSH1 0x00
    020  DUP1
    021  PUSH2 0x0100
    024  EXP
    025  DUP2
    026  SLOAD
    027  DUP2
    028  PUSH20 0xffffffffffffffffffffffffffffffffffffffff
    049  MUL
    050  NOT
    051  AND
    052  SWAP1
    053  DUP4
    054  PUSH20 0xffffffffffffffffffffffffffffffffffffffff
    075  AND
    076  MUL
    077  OR
    078  SWAP1
    079  SSTORE
    080  POP
    081  PUSH1 0x3f
    083  DUP1
    084  PUSH1 0x5d
    086  PUSH1 0x00
    088  CODECOPY
    089  PUSH1 0x00
    091  RETURN
    092  INVALID

    .data
    093  PUSH1 0x80
    095  PUSH1 0x40
    097  MSTORE
    098  PUSH1 0x00
    100  DUP1
    101  REVERT
    102  INVALID

    103  LOG2
    104  PUSH5 0x6970667358
    110  34
    111  SLT
    112  KECCAK256
    113  LT
    114  0xF
    115  0xBE
    116  0xE0
    117  0xE7
    118  TIMESTAMP
    119  0x29
    120  PUSH9 0xcc36db53ccd5f55a88
    130  0xE
    131  COINBASE
    132  0xD8
    133  0xB3
    134  STATICCALL
    135  0xCE
    136  0xD5
    137  PUSH8 0x48bbe24ac957c964
    146  PUSH20 0x6F6C634300080900330000000000000000000000

使用 `--asm` 选项编译示例会在我们的 BytecodeDir 目录中生成一个名为 example.evm 的文件。这个文件包含了 EVM 字节码指令的稍微高级的描述，以及一些有用的注释：

        /* "example.sol":60:176  contract example {... */
      mstore(0x40, 0x80)
        /* "example.sol":114:173  constructor() {... */
      callvalue
      dup1
      iszero
      tag_1
      jumpi
      0x00
      dup1
      revert
    tag_1:
      pop
        /* "example.sol":155:165  msg.sender */
      caller
        /* "example.sol":139:152  contractOwner */
      0x00
      dup1
        /* "example.sol":139:165  contractOwner = msg.sender */
      0x0100
      exp
      dup2
      sload
      dup2
      0xffffffffffffffffffffffffffffffffffffffff
      mul
      not
      and
      swap1
      dup4
      0xffffffffffffffffffffffffffffffffffffffff
      and
      mul
      or
      swap1
      sstore
      pop
        /* "example.sol":60:176  contract example {... */
      dataSize(sub_0)
      dup1
      dataOffset(sub_0)
      0x00
      codecopy
      0x00
      return
    stop
    
    sub_0: assembly {
            /* "example.sol":60:176  contract example {... */
          mstore(0x40, 0x80)
          0x00
          dup1
          revert
    
        auxdata:    0xa2646970667358221220b91548bbaafbdb25773c5efc48e8ce8247a6223f8858dfec26ea8b609a71a3bf6    4736f6c63430008150033
    }

`--bin-runtime`选项产生机器可读的十六进制字节码：

    --bin
    0x6080604052348015600e575f80fd5b50335f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550603e8060595f395ff3fe60806040525f80fdfea2646970667358221220fb692310b5cf16c4af58b8c32a96bcec83585693e0ddc535e4df16e19d7a172e64736f6c63430008150033

    --bin-runtime
    0x60806040525f80fdfea2646970667358221220fb692310b5cf16c4af58b8c32a96bcec83585693e0ddc535e4df16e19d7a172e64736f6c63430008150033

你可以使用在EVM指令集(字节码操作)中给出的操作码列表详细了解这里发生了什么。然而，这是一项相当大的任务，所以我们先从检查前四个指令开始：

    PUSH1 0x80
    PUSH1 0x40
    MSTORE
    CALLVALUE

这里我们有一个PUSH1，后面跟着一个值为0x60的原始字节。这个EVM指令将程序代码中操作码后面的单个字节（作为字面值）推送到堆栈上。可以将最大32字节的值推送到堆栈上，如下：

    PUSH32 0x436f6e67726174756c6174696f6e732120536f6f6e20746f206d617374657221

example.opcode中的第二个PUSH1操作码将0x40存储在堆栈的顶部（将已经存在的0x60推向下一个槽位）。

接下来是MSTORE，这是一个内存存储操作，它将值保存到EVM的内存中。它需要两个参数，像大多数EVM操作一样，从堆栈中获取它们。对于每个参数，堆栈都会被“弹出”；也就是说，从堆栈顶部取出顶部的值，并将堆栈中的所有其他值向上移动一个位置。MSTORE的第一个参数是内存中将要存储值的字的地址。对于这个程序，我们在堆栈顶部有0x40，所以它被从堆栈中移除并用作内存地址。第二个参数是要保存的值，在这里是0x60。执行MSTORE操作后，我们的堆栈再次为空，但在0x40的内存位置我们有值0x60（十进制中的96）。

下一个操作码是CALLVALUE，这是一个环境操作码，它将与启动这个执行的消息调用发送的以太币（以wei测量）的数量推到堆栈的顶部。

我们可以继续这样一步步地遍历这个程序，直到我们完全理解这段代码所产生的低级状态变化，但在这个阶段，它对我们没有帮助。我们将在章节的后面再回到这个问题。

### 

在创建和部署一个新合约到以太坊平台和合约本身的代码之间，存在一个重要但细微的区别。为了创建一个新合约，需要一个特殊的交易，该交易的"to"字段设置为特殊的0x0地址，其数据字段设置为合约的初始化代码。当这样一个合约创建交易被处理时，新合约账户的代码并不是交易数据字段中的代码。相反，将实例化一个EVM，将交易数据字段中的代码加载到其程序代码ROM中，然后将该部署代码执行的输出作为新合约账户的代码。这是为了让新合约可以使用部署时的以太坊世界状态进行编程初始化，设置合约的存储值，甚至发送以太币或创建更多新的合约。

当离线编译一个合约时，例如，使用命令行上的solc，你可以获取部署字节码或运行时字节码。

部署字节码用于新合约账户初始化的每一个方面，包括实际上会在交易调用这个新合约时被执行的字节码（即运行时字节码）和基于合约的构造器初始化所有内容的代码。

另一方面，运行时字节码，只是在新合约被调用时最终被执行的字节码，没有更多；它不包括在部署期间初始化合约所需的字节码。

让我们以我们之前创建的简单Faucet.sol合约为例：

    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.0;

    contract Faucet {
        // Give out ether to anyone who asks
        function withdraw(uint256 withdraw_amount) public {
            // Limit withdrawal amount
            require(withdraw_amount <= 100000000000000000);

            // Send the amount to the address that requested it
            payable(msg.sender).transfer(withdraw_amount);
        }

        // Accept any incoming amount
        constructor() payable {}
    }

要获取部署字节码，我们将运行 `solc --bin Faucet.sol`。如果我们只想要运行时字节码，我们将运行 `solc --bin-runtime Faucet.sol`。

    solc --bin Faucet.sol:
    6080604052348015600e575f80fd5b50335f806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550603e8060595f395ff3fe60806040525f80fdfea264697066735822122029e0046c7ec9b624808127bf992a05ae0aa993babaa9af50d878083cd3587d8f64736f6c63430008150033

    solc --bin-runtime Faucet.sol:
    60806040525f80fdfea264697066735822122029e0046c7ec9b624808127bf992a05ae0aa993babaa9af50d878083cd3587d8f64736f6c63430008150033

如果你比较这些命令的输出，你会看到运行时字节码是部署字节码的一个子集。换句话说，运行时字节码完全包含在部署字节码中。

### 图灵完备性和Gas
正如我们已经提到的，简单来说，如果一个系统或编程语言可以运行任何程序，那么它就是图灵完备的。然而，这种能力有一个非常重要的附加条件：有些程序需要无限的时间才能运行完。这里的一个重要方面是，我们不能仅仅通过查看一个程序就能判断它需要多久才能执行完，我们必须真正地执行这个程序并等待它结束才能知道。当然，如果它需要无限的时间才能执行完，我们将不得不无限期地等待。这就是所谓的停机问题，如果没有解决，它将对以太坊构成巨大的问题。

由于停机问题，以太坊世界计算机有可能被要求执行一个永不停止的程序。这可能是出于意外或恶意。我们已经讨论过，以太坊就像一台单线程机器，没有任何调度器，所以如果它陷入了无限循环，这将意味着它将变得无法使用。

然而，有了gas，就有了解决方案：如果在预设的最大计算量执行完后，程序还没有结束，那么程序的执行就会被EVM终止。这使得EVM成为一种准图灵完备的机器：它可以运行你输入的任何程序，但前提是程序在特定的计算量内结束。这个限制在以太坊中并不是固定的——你可以支付费用来增加它到一个最大值（称为"区块gas限制"），并且每个人都可以同意随着时间的推移增加这个最大值。然而，在任何一个时间点，都会有一个限制，消耗太多gas的交易在执行过程中会被终止。

在以下部分，我们将详细研究gas以及它的工作原理。

### Gas
Gas是以太坊用来衡量在以太坊区块链上执行操作所需的计算和存储资源的单位。与比特币的交易费用只考虑交易大小（以千字节计）不同，以太坊必须考虑交易和智能合约代码执行所进行的每一个计算步骤。

交易或合约执行的每一个操作都会消耗固定数量的gas。以下是一些例子，摘自以太坊黄皮书：
- 加两个数消耗3个gas
- 计算一个Keccak-256哈希消耗30个gas + 每256位被哈希的数据消耗6个gas
- 发送一个交易消耗21,000个gas

Gas是以太坊的关键组成部分，它有两个角色：作为以太坊价格（波动性）和矿工劳动报酬之间的缓冲，以及防御拒绝服务攻击的防线。为了防止网络中的意外或恶意的无限循环或其他计算浪费，每个交易的发起者都需要设定他们愿意支付的计算量上限。gas系统因此阻止攻击者发送"垃圾"交易，因为他们必须按比例支付他们消耗的计算、带宽和存储资源。

### 执行期间的气体记账
当EVM需要完成交易时，首先，它被赋予等于交易中的气体限制所指定的数量的气体供应。每个执行的操作码都有一个气体成本，因此，当EVM通过程序时，EVM的气体供应会减少。在每个操作之前，EVM都会检查是否有足够的气体来支付操作的执行。如果气体不足，执行将被暂停，交易将被撤销。

如果EVM成功地到达执行的结束，没有耗尽气体，使用的气体成本将作为交易费用支付给矿工，根据交易中指定的气体价格转换为以太币：

    矿工费 = 气体成本 * 气体价格
    
剩余的气体将退还给发送者，同样根据交易中指定的气体价格转换为以太币：

    剩余的气体 = 气体限制 - 气体成本
    退还的以太币 = 剩余的气体 * 气体价格

如果交易在执行过程中“耗尽了气体”，操作将立即终止，引发“气体耗尽”的异常。交易被撤销，所有对状态的更改都被回滚。

尽管交易没有成功，但发送者将被收取交易费用，因为矿工已经进行到那一点的计算工作，并必须得到补偿。

### gas记账的考虑
EVM可以执行的各种操作的相对气体成本已经被精心选择，以最好地保护以太坊区块链免受攻击。您可以在[evm_opcodes_table]中看到不同EVM操作码的气体成本的详细表格。

更多的计算密集型操作成本更高。例如，执行SHA3函数的成本是ADD操作(3气体)的10倍（30气体）。更重要的是，有些操作，如EXP，需要根据操作数的大小支付额外的费用。使用EVM内存和在合约的链上存储中存储数据也有气体成本。

2016年，当攻击者发现并利用了成本不匹配时，匹配气体成本与现实世界资源成本的重要性得到了证明。这次攻击生成了非常计算密集的交易，使以太坊主网几乎停滞不前。这种不匹配通过一个硬分叉（代号为“橙色哨子”）得到解决，该硬分叉调整了相对气体成本。

### 燃气费用与燃气价格
虽然燃气成本是衡量在以太坊虚拟机（EVM）中使用的计算和存储的一种方式，但燃气本身也有一个用以太币衡量的价格。进行交易时，发件人指定他们愿意支付的每单位燃气的价格（以以太币计），让市场决定以太币的价格和计算操作成本（以燃气计量）之间的关系：

    交易费 = 总燃气使用量 * 支付的燃气价格（以以太币计）

在构建新区块时，以太坊网络上的矿工可以选择待处理的交易，选择那些提供支付更高燃气价格的交易。因此，提供更高的燃气价格将激励矿工包含你的交易，并使其更快地得到确认。

实际上，交易的发送者会设定一个燃气限额，这个限额高于或等于预期使用的燃气量。如果燃气限额设定的比消耗的燃气量多，发送者将收到超出部分的退款，因为矿工只会为他们实际执行的工作得到补偿。

区分燃气成本和燃气价格非常重要。回顾一下：
- 燃气成本是执行特定操作所需的燃气单位数。
- 燃气价格是你在向以太坊网络发送交易时愿意支付的每单位燃气的以太币金额。

> 提示
> 虽然燃气有价格，但它不能被“拥有”也不能被“花费”。燃气只存在于EVM内部，作为正在执行的计算工作的计数。发送者将被收取以太币的交易费，然后转换为EVM的燃气计费，然后再转换回以太币作为支付给矿工的交易费。

#### 负燃气成本
以太坊通过退还在合约执行期间使用的部分燃气，鼓励删除已使用的存储变量和账户。

EVM中有两个具有负燃气成本的操作：
- 删除合约（SELFDESTRUCT）值得退还24000燃气。
- 将存储地址从非零值改为零（SSTORE[x] = 0）值得退还15000燃气。

为避免退款机制被滥用，交易的最大退款金额设定为使用的燃气总量的一半（向下取整）。

### 区块燃气限制
区块燃气限制是一个区块中所有交易可能消耗的燃气的最大量，它限制了一个区块中可以容纳的交易数量。

例如，假设我们有5笔交易，它们的燃气限制被设定为30,000，30,000，40,000，50,000和50,000。如果区块燃气限制是180,000，那么任意四笔交易可以被放入一个区块，而第五笔交易则必须等待未来的区块。如前所述，矿工决定将哪些交易包含在一个区块中。不同的矿工可能会选择不同的组合，主要是因为他们从网络中以不同的顺序接收到交易。

如果矿工试图包含一笔需要更多燃气的交易超过当前区块燃气限制，该区块将被网络拒绝。大多数以太坊客户端会阻止你发出这样的交易，并给出“交易超过区块燃气限制”的警告。在撰写本文时，以太坊主网的区块燃气限制是8百万燃气，意味着大约380笔基本交易（每笔消耗21,000燃气）可以放入一个区块。

#### 谁决定区块燃气限制是多少？
网络上的矿工共同决定区块燃气限制。想在以太坊网络上进行挖矿的个人使用挖矿程序，如Ethminer，它连接到Geth或Parity以太坊客户端。以太坊协议有一个内置机制，矿工可以投票决定燃气限制，以便在后续区块中增加或减少容量。一个区块的矿工可以投票调整区块燃气限制，调整幅度为1/1,024（0.0976%）的因子，方向可以是任意的。这个结果是基于网络当前需求的可调整区块大小。这种机制与默认的挖矿策略相结合，矿工投票的燃气限制至少为4.7百万燃气，但目标值是最近每个区块的总燃气使用量的150%的平均值（使用1,024区块的指数移动平均值）。

## 结论
在这一章中，我们探讨了以太坊虚拟机，追踪了各种智能合约的执行，并查看了EVM如何执行字节码。我们还研究了燃气，EVM的会计机制，看到它如何解决停机问题并保护以太坊免受拒绝服务攻击。接下来，在[共识]中，我们将研究以太坊实现去中心化共识的机制。
